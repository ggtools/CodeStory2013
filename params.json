{"name":"Codestory2013","tagline":"Journal de ma participation à CodeStory2013","body":"## Au début …\r\n\r\nIl n'y avait rien. Enfin pas complètement rien car il y avait ça :\r\n\r\n> Chaque développeur […] devra également installer un serveur web public […] l’équipe de CodeStory va poser une question au serveur […] au travers d’une requête http GET. […] La réponse doit être fournie dans le body de la réponse de la requête http.\r\n\r\n> La première question est simple. […] `http://(serveur)/?q=Quelle+est+ton+adresse+email` de votre serveur doit répondre par un document ne contenant que votre adresse email.\r\n\r\nN'ayant pas *a priori* trop de temps à consacrer à Code Story j'ai préféré rester dans le classique : Java 7 & Tomcat. Pour l'hébergement, j'avais ouvert un compte sur [Cloudbees](http:/www.cloudbees.com/) depuis la présentation de [Nicolas De Loof](http://www.loof.fr/) au [BordeauxJUG](http://www.bordeauxjug.org) que j'allais pouvoir mettre à contribution.\r\n\r\n## Premières questions\r\n\r\nL'implémentation des premières questions se fait rapidement en jetant un coup d'œil sur les logs et en ajoutant le couple question/réponse avant de redéployer. Lorsqu'arrive \"`Es tu pret a recevoir une enonce au format markdown par http post(OUI/NON)`\" je pars sur une implémentation minimale (\"use the logs Luke\" me souffle une petite voix dans ma tête).\r\n\r\nCette première partie ne posa pas de problème & ne fut pas chronophage : jusque là tout va bien …\r\n\r\n## L'échoppe de monade sur Scalaskel\r\n\r\nJ'ai commencé pour un rapide refactoring pour introduire l'interface `Resolver`. Ensuite un rapide brainstorming avec moi même pour choisir Jackson pour le formatage du JSon. L'algorithme final est récursif et utilise une enum pour stocker les différentes pièces :\r\n\r\n```java\r\nprotected List<Map<COIN, Integer>> computeChange(COIN currentCoin, int value) {\r\n    if (currentCoin.getValue() == 1) {\r\n        Map<COIN, Integer> changeMap = Maps.newHashMapWithExpectedSize(COIN.values().length);\r\n        addToChange(currentCoin, value, changeMap);\r\n        return Lists.newArrayList(changeMap);\r\n    }\r\n    int maxCoins = value / currentCoin.getValue();\r\n    List<Map<COIN, Integer>> results = Lists.newArrayList();\r\n    for (int i = 0; i <= maxCoins; i++) {\r\n        List<Map<COIN, Integer>> subChanges = computeChange(COIN.values()[currentCoin.ordinal() - 1], value - i * currentCoin.getValue());\r\n        for (Map<COIN, Integer> change : subChanges) {\r\n            addToChange(currentCoin, i, change);\r\n            results.add(change);\r\n        }\r\n    }\r\n    return results;\r\n}\r\n```\r\n\r\nDéploiement, petits coup d'œil aux logs pour surveiller le passage du robot … *yes !* il est passé & visiblement mes résultats sont corrects. Et puis arrive ça : `1 1` … \r\n\r\n## Calculatrice\r\n\r\nSolitude, interrogation avant de me rendre compte qu'il fallait regarder la question **avant** décodage du paramètre. J'ai fait deux implémentation de la calculatrice : une première en utilisant [exp4j](http://www.objecthunter.net/exp4j/index.html) plutôt que Groovy qui ressemblait à un marteau-pillon pour casser une noix. Ça a marché pas trop mal jusqu'à ça :\r\n\r\n    ((1,1+2)+3,14+4+(5+6+7)+(8+9+10)*4267387833344334647677634)/2*553344300034334349999000\r\n\r\nExp4j faisant les calculs avec des doubles j'ai perdu du monde au passage et le robot n'a pas aimé. La solution est bien sûr de passer par `BigDecimal` mais exp4j n'est malheureusement pas conçu autour d'un pattern visitor donc très très difficile de changer la manière dont sont fait les calculs.\r\n\r\nFinalement le marteau-pillon a du bon et Groovy ce sera.\r\n\r\n## Jajascript\r\n\r\nPour le deuxième énoncé je commence par une implémentation récursive et assez simple :\r\n\r\n```java\r\nPlan computePlan(Flight[] flights) {\r\n    Plan plan = null;\r\n    for (int i = 0; i < flights.length; i++) {\r\n        Flight current = flights[i];\r\n        List<Flight> selectedFlights = new ArrayList<>(flights.length - i);\r\n        for (int j = i + 1; j < flights.length; j++) {\r\n            Flight candidate = flights[j];\r\n            if (current.isCompatibleWith(candidate)) {\r\n                selectedFlights.add(candidate);\r\n            }\r\n        }\r\n\r\n        Plan currentPlan;\r\n        int gain;\r\n        if (selectedFlights.isEmpty()) {\r\n            gain = current.getPrix();\r\n            currentPlan = new Plan(gain, Arrays.asList(current));\r\n        } else {\r\n            Flight[] subArray = selectedFlights.toArray(new Flight[selectedFlights.size()]);\r\n            currentPlan = computePlan(subArray);\r\n            gain = current.getPrix() + currentPlan.getGain();\r\n            List<Flight> path = new ArrayList<>(currentPlan.getPath().size() + 1);\r\n            path.add(current);\r\n            path.addAll(currentPlan.getPath());\r\n            currentPlan = new Plan(gain, path);\r\n        }\r\n\r\n        if (plan == null || plan.getGain() < gain) {\r\n            plan = currentPlan;\r\n        }\r\n    }\r\n    return plan;\r\n}\r\n```\r\n\r\nLes quelques tests donnent des résultats assez satisfaisant en terme de temps de réponse. Le robot étant en RTT le week-end où j'ai codé mon algorithme je me suis lancé confiant dans le codage d'un petit test de performance qui va faire des tests avec un nombre variable de vols. Et là … catastrophe, les temps de réponses deviennent catastrophiques lorsque je dépasse 100 vols. J'essaye des améliorations comme trier la liste des vols avant de commencer le traitement mais ça ne change rien. Il va falloir un changement radical d'algorithme. \r\n\r\n### Jajascript itératif\r\n\r\nJ'ai passé pas mal de temps à réfléchir à un algo en regardant du côté des graphes, des arbres avec élagage par alpha/beta sans que cela me convainque. Au final j'ai eu une illumination et je suis sorti avec un algo sur mesure pour le problème :\r\n\r\n* On va découper la journée de location en un certain nombre de *slots* (au début naïf je me disais qu'il y aurait 24 heures max dans la journée mais je n'avais pas tenu compte de la rotation particulièrement lente de Jajascript).\r\n* Dans un premier temps on va assigner chaque vol au slot correspondant à son début.\r\n* On parcours ensuite la liste des slots en commençant par la fin et pour chaque slot:\r\n    * On parcours la liste des vols du slot et on calcule le gain pour chaque vol en additionnant le gain du vol avec le gain du slot suivant la fin du vol.\r\n    * Le vol avec le meilleur gain devient le vol sélectionné pour ce slot.\r\n\r\nAu final les temps de réponse sont pas mal du tout et la complexité est très proche de o(n).\r\n\r\n![Durée en fonction du nombre de vols hors JSon](images/jajascript.png)\r\n\r\n```java\r\nint maxGain = -1;\r\nSlot selectedSlot = null;\r\nfor (int i = slots.length - 2; i >= 0; i--) {\r\n    Slot currentSlot = slots[i];\r\n    Slot selectedNextSlot = slots[i + 1];\r\n    int gain = selectedNextSlot.getGain();\r\n\r\n    Flight selectedFlight = null;\r\n    for (Flight flight : currentSlot.getFlights()) {\r\n        Slot nextSlot = slots[flight.getEnd()];\r\n        int currentGain = flight.getPrix() + nextSlot.getGain();\r\n        if (currentGain > gain) {\r\n            selectedFlight = flight;\r\n            gain = currentGain;\r\n            selectedNextSlot = nextSlot;\r\n        }\r\n    }\r\n\r\n    currentSlot.setGain(gain);\r\n    if (selectedFlight != null) currentSlot.getPath().add(selectedFlight);\r\n    currentSlot.getPath().addAll(selectedNextSlot.getPath());\r\n\r\n    if (currentSlot.getGain() > maxGain) {\r\n        maxGain = currentSlot.getGain();\r\n        selectedSlot = currentSlot;\r\n    }\r\n}\r\n\r\nassert selectedSlot != null;\r\nreturn new Plan(maxGain, selectedSlot.getPath());\r\n```\r\n\r\nPour la petite histoire j'ai eu l'idée de l'algorithme un dimanche avant de me coucher. Je me suis dit : *c'est bon il est déjà 1h je vais dormir maintenant et je coderai ça demain*. Ça a été une grossière erreur puisque j'ai très mal dormi.\r\n\r\n### J'ai la mémoire qui flanche (air chantant)\r\n\r\nLorsque le robot est revenu de week-end, tout s'est très bien passé jusqu'à 10000 ou 50000 vols car sur mon instance gratuite Cloudbees le calcul se terminait par une magnifique `OutOfMemoryException`. J'ai augmenté la taille de mon instance jusqu'à 512Mb mais j'avais toujours le même problème. J'ai donc dû faire des optimisations drastiques en évitant à tout prix les recopies de tableaux dans les `ArrayList`.\r\n\r\nLa version finale a réussi à passer l'intégralité des tests sur une instance gratuite.\r\n\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}